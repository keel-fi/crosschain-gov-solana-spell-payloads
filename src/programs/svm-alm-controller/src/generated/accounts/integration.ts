/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getIntegrationConfigDecoder,
  getIntegrationConfigEncoder,
  getIntegrationStateDecoder,
  getIntegrationStateEncoder,
  getIntegrationStatusDecoder,
  getIntegrationStatusEncoder,
  type IntegrationConfig,
  type IntegrationConfigArgs,
  type IntegrationState,
  type IntegrationStateArgs,
  type IntegrationStatus,
  type IntegrationStatusArgs,
} from '../types';

export type Integration = {
  controller: Address;
  description: ReadonlyUint8Array;
  hash: ReadonlyUint8Array;
  status: IntegrationStatus;
  rateLimitSlope: bigint;
  rateLimitMaxOutflow: bigint;
  rateLimitOutflowAmountAvailable: bigint;
  rateLimitRemainder: bigint;
  lastRefreshTimestamp: bigint;
  lastRefreshSlot: bigint;
  config: IntegrationConfig;
  state: IntegrationState;
  permitLiquidation: boolean;
  padding: ReadonlyUint8Array;
};

export type IntegrationArgs = {
  controller: Address;
  description: ReadonlyUint8Array;
  hash: ReadonlyUint8Array;
  status: IntegrationStatusArgs;
  rateLimitSlope: number | bigint;
  rateLimitMaxOutflow: number | bigint;
  rateLimitOutflowAmountAvailable: number | bigint;
  rateLimitRemainder: number | bigint;
  lastRefreshTimestamp: number | bigint;
  lastRefreshSlot: number | bigint;
  config: IntegrationConfigArgs;
  state: IntegrationStateArgs;
  permitLiquidation: boolean;
  padding: ReadonlyUint8Array;
};

export function getIntegrationEncoder(): FixedSizeEncoder<IntegrationArgs> {
  return getStructEncoder([
    ['controller', getAddressEncoder()],
    ['description', fixEncoderSize(getBytesEncoder(), 32)],
    ['hash', fixEncoderSize(getBytesEncoder(), 32)],
    ['status', getIntegrationStatusEncoder()],
    ['rateLimitSlope', getU64Encoder()],
    ['rateLimitMaxOutflow', getU64Encoder()],
    ['rateLimitOutflowAmountAvailable', getU64Encoder()],
    ['rateLimitRemainder', getU64Encoder()],
    ['lastRefreshTimestamp', getI64Encoder()],
    ['lastRefreshSlot', getU64Encoder()],
    ['config', getIntegrationConfigEncoder()],
    ['state', getIntegrationStateEncoder()],
    ['permitLiquidation', getBooleanEncoder()],
    ['padding', fixEncoderSize(getBytesEncoder(), 87)],
  ]);
}

export function getIntegrationDecoder(): FixedSizeDecoder<Integration> {
  return getStructDecoder([
    ['controller', getAddressDecoder()],
    ['description', fixDecoderSize(getBytesDecoder(), 32)],
    ['hash', fixDecoderSize(getBytesDecoder(), 32)],
    ['status', getIntegrationStatusDecoder()],
    ['rateLimitSlope', getU64Decoder()],
    ['rateLimitMaxOutflow', getU64Decoder()],
    ['rateLimitOutflowAmountAvailable', getU64Decoder()],
    ['rateLimitRemainder', getU64Decoder()],
    ['lastRefreshTimestamp', getI64Decoder()],
    ['lastRefreshSlot', getU64Decoder()],
    ['config', getIntegrationConfigDecoder()],
    ['state', getIntegrationStateDecoder()],
    ['permitLiquidation', getBooleanDecoder()],
    ['padding', fixDecoderSize(getBytesDecoder(), 87)],
  ]);
}

export function getIntegrationCodec(): FixedSizeCodec<
  IntegrationArgs,
  Integration
> {
  return combineCodec(getIntegrationEncoder(), getIntegrationDecoder());
}

export function decodeIntegration<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Integration, TAddress>;
export function decodeIntegration<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Integration, TAddress>;
export function decodeIntegration<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Integration, TAddress> | MaybeAccount<Integration, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getIntegrationDecoder()
  );
}

export async function fetchIntegration<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Integration, TAddress>> {
  const maybeAccount = await fetchMaybeIntegration(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeIntegration<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Integration, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeIntegration(maybeAccount);
}

export async function fetchAllIntegration(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Integration>[]> {
  const maybeAccounts = await fetchAllMaybeIntegration(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeIntegration(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Integration>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeIntegration(maybeAccount));
}

export function getIntegrationSize(): number {
  return 507;
}
